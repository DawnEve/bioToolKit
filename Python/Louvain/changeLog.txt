# https://blog.csdn.net/qq_16543881/article/details/122825957
# https://github.com/xmweijh/CommunityDetection/blob/main/Louvain.py
# with resolution: https://github.com/taynaud/python-louvain

##############
# 社区检测 (community detection) 测试数据说明:
# data/UMAP_coord.df.txt 共3列，前2列是数据点的UMAP坐标，可以理解为x/y二维坐标，第三列是一个金标准 社区分类。
# data/snn_df.txt 共3列，前两列是数据的顶点编号，第三列是边的权重；这就是网络输入文件
#    使用算法 社区检测 后，画到UMAP坐标上，和金标准比较看差异。
#    只要是成片的，不重叠，边界大致一致，总类数不要太多就可以了(5-15个类比较理想)。
##############


文件说明:
* Louvain_1.py 可以检测社区，然后画图，搜到的实现; 模板;
* Louvain_2.py 仅检测社区，注释 phageI; 添加 iter 次数 计数器;
* Louvain_3.py 仅检测社区，注释 phageII; 同时输出到文件，输出成2列标签数字(顶点id 社区id)
* 调包 community_v1.py (官方实现的调包，带分辨率) 测试 10x 数据: 输入SNN稀疏矩阵，输出2列，和 Seurat 结果作比较。
	效果差不多。就是 resolution 比较怪异: 调大或调小都可能导致 clsuter 数增大。

* pyLouvain_v1.py 和 Seurat 结果差距较大，有些cluster在UMAP上是撕裂的。速度慢。
* Louvain_4.py 测试 10x 数据: 输入SNN稀疏矩阵，输出2列，和 Seurat 结果作比较。每个cell一类，失败。
*v0.1.7@Louvain pyLouvain_v2.py py 可视化
*v0.1.8@Louvain Louvain_4.py 修订版 v2.0, pbmc 3k 数据集可用，虽然不好；但是 10 点小数据集不行;
*v0.1.9@Louvain github_v1.py 测试: 大小样本都通过; 不支持分辨率 [Good]
*v0.2.0@Louvain Louvain_5.py 没有添加 deltaQ(D->i)，只是调整代码顺序; 大小样本都通过; 不支持分辨率 [Good]
*v0.2.0@Louvain 添加2个数据文件: pbmc 3k 的 UMAP 坐标 和 Seurat 的参考分类； RNA_SNN 权重图数据；











R 版本的: https://www.statworx.com/en/content-hub/blog/community-detection-with-louvain-and-infomap/
py可视化分类结果: https://blog.csdn.net/qq_34356768/article/details/104888579



####################
# 数据文件的获取步骤:
==> Step1: 从 Seurat 4 对象获取3列稀疏矩阵:
####
snn=pbmc@graphs$RNA_snn
dim(snn) #2638 2638

# 转为稀疏矩阵
library(Matrix)
class(snn)
snn2=as(snn, "dgCMatrix")

# 检测大小
object.size(snn)  #2811480 bytes
object.size(snn2) #2811256 bytes 确实小了一点点

snn2[1:10,1:5]
snn_df=as.data.frame(summary(snn2))
snn_df[1:5,]
#    i j          x
#1   1 1 1.00000000
#2   7 1 0.11111111

dim(snn_df) #[1] 194568      3

# 写入文件
write.table(snn_df, "backup/snn_df.txt", quote = F, row.names = F, col.names = F)


# UMAP 坐标文件:
dif=as.data.frame(Embeddings(pbmc, reduction = "umap"))[,1:2]
colnames(dif)=c("x", "y")
dif$seurat_clusters=pbmc2$seurat_clusters


dif2=dif[,1:3]
dim(dif2) #[1] 2638    3
write.table(dif2, "backup/UMAP_coord.df.txt", row.names = F, quote = F)
####

检查:
$ head backup/snn_df.txt 
1 1 1
7 1 0.111111111111111
77 1 0.0810810810810811
103 1 0.212121212121212
168 1 0.0810810810810811

194568  583704 5145564 backup/snn_df.txt

检查2:
$ head backup/UMAP_coord.df.txt 
x y seurat_clusters
-3.30455462695531 -3.91470349746861 2
-5.62071196795873 10.6823295263656 3
-5.63014428378515 -6.4006267877213 2

2639  7917 98136 backup/UMAP_coord.df.txt



==> step2: input to Louvain_4.py
####################







